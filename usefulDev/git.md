Подозреваю, что вы добавили файлы в индекс раньше, чем начали игнорировать. То есть до той git add ., который на 
скриншоте, была еще одна такая команда. Чтобы узнать точно, не хватает git status перед добавлением.

Если файл уже был добавлен, то изменение в .gitignore не вызывает удаления из текущего индекса (что логично и 
безопасно).

Если файлы только добавлены, но еще не включены в коммит

В данном конкретном случае именно так и есть. При этом достаточно удалить их из индекса. Данная команда возвращает 
индекс к HEAD, то есть состоянию последнего коммита.

**git reset <file-name>**
Вы можете заметить, что сам Git предлагает использовать другую команду:

**git rm --cached <file-name>** 
В данном случае эти команды эквивалентны. Такое дублирование появилось в результате эволюционного развития функционала
Git. Это в том числе отражено в документации и в сообщениях Git: где-то рекомендуется reset, где-то rm --cached.

Если игнорируемые файлы уже есть в последнем коммите

Возможна и такая ситуация, на всякий случай я опишу и ее. Здесь reset не сработает, нужен rm. Аргумент --cached
заставляет Git удалить файл из индекса, но не трогать рабочую область. То есть он буквально индексирует удаление файла,
хотя этого удаления не было. Если сделать это с файлом, который не игнорируется, то после коммита он будет в категории
неотслеживаемых (untracked).

**git rm --cached <file-name>** 
Если нужно убрать целую игнорируемую папку, добавляем ключ -r:

**git rm -r --cached <path>**
Эта удобная команда применяет rm ко всем файлам, указанным в .gitignore:

**git rm --cached `git ls-files -i --exclude-from=.gitignore`** 
Вариант того же для windows powershell:

**foreach ($i in iex 'git ls-files -i --exclude-from=.gitignore') { git rm --cached $i }**
Теперь результат команды git rm нужно зафиксировать коммитом.

**git commit -m'removed gitignored files'**